/* tslint:disable */
/* eslint-disable */
/**
 * Dognews Server API
 * Dognews Server client API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An article is an approved submission and it takes the title and description from either the automated bots or the moderation, if the moderator entered any
 * @export
 * @interface Article
 */
export interface Article {
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    target_url: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    thumbnail: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    last_updated: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    date_created: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    submitter: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    approver: string;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token: string;
}
/**
 * The result of a bot retrieving the information
 * @export
 * @interface Fetch
 */
export interface Fetch {
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    url: string;
    /**
     * 
     * @type {FetchStatusEnum}
     * @memberof Fetch
     */
    status?: FetchStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    owner: string;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    thumbnail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    generated_thumbnail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    thumbnail_image?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    fetched_page?: string;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    last_updated: string;
    /**
     * 
     * @type {string}
     * @memberof Fetch
     */
    date_created: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum FetchStatusEnum {
    pending = 'pending',
    fetched = 'fetched',
    rej_error = 'rej_error',
    rej_fetch = 'rej_fetch'
}

/**
 * A human evaluation of a submission
 * @export
 * @interface Moderation
 */
export interface Moderation {
    /**
     * 
     * @type {string}
     * @memberof Moderation
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof Moderation
     */
    target_url: string;
    /**
     * 
     * @type {ModerationStatusEnum}
     * @memberof Moderation
     */
    status?: ModerationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Moderation
     */
    owner: string;
    /**
     * 
     * @type {string}
     * @memberof Moderation
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Moderation
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Moderation
     */
    last_updated: string;
    /**
     * 
     * @type {string}
     * @memberof Moderation
     */
    date_created: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ModerationStatusEnum {
    pending = 'pending',
    accepted = 'accepted',
    rejected = 'rejected'
}

/**
 * 
 * @export
 * @interface PaginatedArticleList
 */
export interface PaginatedArticleList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedArticleList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArticleList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArticleList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Article>}
     * @memberof PaginatedArticleList
     */
    results?: Array<Article>;
}
/**
 * 
 * @export
 * @interface PaginatedFetchList
 */
export interface PaginatedFetchList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFetchList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFetchList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFetchList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Fetch>}
     * @memberof PaginatedFetchList
     */
    results?: Array<Fetch>;
}
/**
 * 
 * @export
 * @interface PaginatedModerationList
 */
export interface PaginatedModerationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedModerationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModerationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModerationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Moderation>}
     * @memberof PaginatedModerationList
     */
    results?: Array<Moderation>;
}
/**
 * 
 * @export
 * @interface PaginatedSubmissionList
 */
export interface PaginatedSubmissionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSubmissionList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSubmissionList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSubmissionList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Submission>}
     * @memberof PaginatedSubmissionList
     */
    results?: Array<Submission>;
}
/**
 * 
 * @export
 * @interface PaginatedUserList
 */
export interface PaginatedUserList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof PaginatedUserList
     */
    results?: Array<User>;
}
/**
 * 
 * @export
 * @interface PaginatedVoteList
 */
export interface PaginatedVoteList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedVoteList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVoteList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVoteList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Vote>}
     * @memberof PaginatedVoteList
     */
    results?: Array<Vote>;
}
/**
 * The result of a bot retrieving the information
 * @export
 * @interface PatchedFetch
 */
export interface PatchedFetch {
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    url?: string;
    /**
     * 
     * @type {FetchStatusEnum}
     * @memberof PatchedFetch
     */
    status?: FetchStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    thumbnail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    generated_thumbnail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    thumbnail_image?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    fetched_page?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    last_updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFetch
     */
    date_created?: string;
}
/**
 * A human evaluation of a submission
 * @export
 * @interface PatchedModeration
 */
export interface PatchedModeration {
    /**
     * 
     * @type {string}
     * @memberof PatchedModeration
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModeration
     */
    target_url?: string;
    /**
     * 
     * @type {ModerationStatusEnum}
     * @memberof PatchedModeration
     */
    status?: ModerationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedModeration
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModeration
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModeration
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModeration
     */
    last_updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModeration
     */
    date_created?: string;
}
/**
 * A submission object that is in initial processing
 * @export
 * @interface PatchedSubmission
 */
export interface PatchedSubmission {
    /**
     * 
     * @type {number}
     * @memberof PatchedSubmission
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    target_url?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubmission
     */
    fetch?: string;
}
/**
 * 
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    url?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof PatchedUser
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    email?: string;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof PatchedUser
     */
    groups?: Array<number>;
}
/**
 * A submission object that is in initial processing
 * @export
 * @interface Submission
 */
export interface Submission {
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    target_url: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    owner: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    fetch: string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    access: string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    refresh: string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    access: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    refresh: string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    token: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    url: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof User
     */
    groups?: Array<number>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ValueEnum {
    NUMBER_1 = 1,
    NUMBER_MINUS_1 = -1,
    NUMBER_MINUS_100 = -100
}

/**
 * Votes are provided in Lists and don\'t link back to their submissions once serialized
 * @export
 * @interface Vote
 */
export interface Vote {
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    id: number;
    /**
     * 
     * @type {ValueEnum}
     * @memberof Vote
     */
    value?: ValueEnum;
    /**
     * 
     * @type {string}
     * @memberof Vote
     */
    last_updated: string;
    /**
     * 
     * @type {string}
     * @memberof Vote
     */
    date_created: string;
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    submission: number;
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    owner: number;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json  **Permission restrictions:** + `AllowAny`: *Allow any access.     This isn\'t strictly required, since you could use an empty     permission_classes list, but it\'s useful because it makes the intention     more explicit.*
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemaRetrieve: async (format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenCreate: async (tokenObtainPair: TokenObtainPair, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('apiTokenCreate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenRefreshCreate: async (tokenRefresh: TokenRefresh, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('apiTokenRefreshCreate', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenVerifyCreate: async (tokenVerify: TokenVerify, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('apiTokenVerifyCreate', 'tokenVerify', tokenVerify)
            const localVarPath = `/api/token/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json  **Permission restrictions:** + `AllowAny`: *Allow any access.     This isn\'t strictly required, since you could use an empty     permission_classes list, but it\'s useful because it makes the intention     more explicit.*
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSchemaRetrieve(format, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenCreate(tokenObtainPair: TokenObtainPair, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenCreate(tokenObtainPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenRefreshCreate(tokenRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenVerifyCreate(tokenVerify: TokenVerify, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerify>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenVerifyCreate(tokenVerify, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json  **Permission restrictions:** + `AllowAny`: *Allow any access.     This isn\'t strictly required, since you could use an empty     permission_classes list, but it\'s useful because it makes the intention     more explicit.*
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiSchemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenCreate(tokenObtainPair: TokenObtainPair, options?: any): AxiosPromise<TokenObtainPair> {
            return localVarFp.apiTokenCreate(tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.apiTokenRefreshCreate(tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenVerifyCreate(tokenVerify: TokenVerify, options?: any): AxiosPromise<TokenVerify> {
            return localVarFp.apiTokenVerifyCreate(tokenVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json  **Permission restrictions:** + `AllowAny`: *Allow any access.     This isn\'t strictly required, since you could use an empty     permission_classes list, but it\'s useful because it makes the intention     more explicit.*
     * @param {'json' | 'yaml'} [format] 
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any) {
        return ApiApiFp(this.configuration).apiSchemaRetrieve(format, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} tokenObtainPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiTokenCreate(tokenObtainPair: TokenObtainPair, options?: any) {
        return ApiApiFp(this.configuration).apiTokenCreate(tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any) {
        return ApiApiFp(this.configuration).apiTokenRefreshCreate(tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} tokenVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiTokenVerifyCreate(tokenVerify: TokenVerify, options?: any) {
        return ApiApiFp(this.configuration).apiTokenVerifyCreate(tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArticlesApi - axios parameter creator
 * @export
 */
export const ArticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Final accepted articles, read only view. *Public*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesList: async (limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Final accepted articles, read only view. *Public*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('articlesRetrieve', 'id', id)
            const localVarPath = `/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * Final accepted articles, read only view. *Public*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async articlesList(limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedArticleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.articlesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Final accepted articles, read only view. *Public*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async articlesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.articlesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArticlesApiFp(configuration)
    return {
        /**
         * Final accepted articles, read only view. *Public*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedArticleList> {
            return localVarFp.articlesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Final accepted articles, read only view. *Public*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesRetrieve(id: number, options?: any): AxiosPromise<Article> {
            return localVarFp.articlesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI {
    /**
     * Final accepted articles, read only view. *Public*
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesList(limit?: number, offset?: number, options?: any) {
        return ArticlesApiFp(this.configuration).articlesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Final accepted articles, read only view. *Public*
     * @param {number} id A unique integer value identifying this submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesRetrieve(id: number, options?: any) {
        return ArticlesApiFp(this.configuration).articlesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCreate: async (username: string, password: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authLoginCreate', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('authLoginCreate', 'password', password)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authLoginCreate', 'token', token)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
            if (token !== undefined) { 
                localVarFormParams.append('token', token as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginCreate(username: string, password: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginCreate(username, password, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCreate(username: string, password: string, token: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.authLoginCreate(username, password, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginCreate(username: string, password: string, token: string, options?: any) {
        return AuthApiFp(this.configuration).authLoginCreate(username, password, token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FetchsApi - axios parameter creator
 * @export
 */
export const FetchsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsCreate: async (fetch?: Fetch, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fetchs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fetch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsDestroy: async (submission: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('fetchsDestroy', 'submission', submission)
            const localVarPath = `/fetchs/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsList: async (limit?: number, offset?: number, ordering?: string, status?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fetchs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {PatchedFetch} [patchedFetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsPartialUpdate: async (submission: number, patchedFetch?: PatchedFetch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('fetchsPartialUpdate', 'submission', submission)
            const localVarPath = `/fetchs/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFetch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsRetrieve: async (submission: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('fetchsRetrieve', 'submission', submission)
            const localVarPath = `/fetchs/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsUpdate: async (submission: number, fetch?: Fetch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('fetchsUpdate', 'submission', submission)
            const localVarPath = `/fetchs/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fetch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FetchsApi - functional programming interface
 * @export
 */
export const FetchsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FetchsApiAxiosParamCreator(configuration)
    return {
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchsCreate(fetch?: Fetch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fetch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchsCreate(fetch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchsDestroy(submission: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchsDestroy(submission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchsList(limit?: number, offset?: number, ordering?: string, status?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFetchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchsList(limit, offset, ordering, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {PatchedFetch} [patchedFetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchsPartialUpdate(submission: number, patchedFetch?: PatchedFetch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fetch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchsPartialUpdate(submission, patchedFetch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchsRetrieve(submission: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fetch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchsRetrieve(submission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchsUpdate(submission: number, fetch?: Fetch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fetch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchsUpdate(submission, fetch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FetchsApi - factory interface
 * @export
 */
export const FetchsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FetchsApiFp(configuration)
    return {
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsCreate(fetch?: Fetch, options?: any): AxiosPromise<Fetch> {
            return localVarFp.fetchsCreate(fetch, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsDestroy(submission: number, options?: any): AxiosPromise<void> {
            return localVarFp.fetchsDestroy(submission, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsList(limit?: number, offset?: number, ordering?: string, status?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', options?: any): AxiosPromise<PaginatedFetchList> {
            return localVarFp.fetchsList(limit, offset, ordering, status, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {PatchedFetch} [patchedFetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsPartialUpdate(submission: number, patchedFetch?: PatchedFetch, options?: any): AxiosPromise<Fetch> {
            return localVarFp.fetchsPartialUpdate(submission, patchedFetch, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsRetrieve(submission: number, options?: any): AxiosPromise<Fetch> {
            return localVarFp.fetchsRetrieve(submission, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this fetch.
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchsUpdate(submission: number, fetch?: Fetch, options?: any): AxiosPromise<Fetch> {
            return localVarFp.fetchsUpdate(submission, fetch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FetchsApi - object-oriented interface
 * @export
 * @class FetchsApi
 * @extends {BaseAPI}
 */
export class FetchsApi extends BaseAPI {
    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {Fetch} [fetch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FetchsApi
     */
    public fetchsCreate(fetch?: Fetch, options?: any) {
        return FetchsApiFp(this.configuration).fetchsCreate(fetch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FetchsApi
     */
    public fetchsDestroy(submission: number, options?: any) {
        return FetchsApiFp(this.configuration).fetchsDestroy(submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FetchsApi
     */
    public fetchsList(limit?: number, offset?: number, ordering?: string, status?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', options?: any) {
        return FetchsApiFp(this.configuration).fetchsList(limit, offset, ordering, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this fetch.
     * @param {PatchedFetch} [patchedFetch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FetchsApi
     */
    public fetchsPartialUpdate(submission: number, patchedFetch?: PatchedFetch, options?: any) {
        return FetchsApiFp(this.configuration).fetchsPartialUpdate(submission, patchedFetch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FetchsApi
     */
    public fetchsRetrieve(submission: number, options?: any) {
        return FetchsApiFp(this.configuration).fetchsRetrieve(submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this fetch.
     * @param {Fetch} [fetch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FetchsApi
     */
    public fetchsUpdate(submission: number, fetch?: Fetch, options?: any) {
        return FetchsApiFp(this.configuration).fetchsUpdate(submission, fetch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModerationsApi - axios parameter creator
 * @export
 */
export const ModerationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsCreate: async (moderation?: Moderation, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/moderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moderation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsDestroy: async (submission: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('moderationsDestroy', 'submission', submission)
            const localVarPath = `/moderations/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'accepted' | 'pending' | 'rejected'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsList: async (limit?: number, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rejected', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/moderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {PatchedModeration} [patchedModeration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsPartialUpdate: async (submission: number, patchedModeration?: PatchedModeration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('moderationsPartialUpdate', 'submission', submission)
            const localVarPath = `/moderations/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedModeration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsRetrieve: async (submission: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('moderationsRetrieve', 'submission', submission)
            const localVarPath = `/moderations/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsUpdate: async (submission: number, moderation?: Moderation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('moderationsUpdate', 'submission', submission)
            const localVarPath = `/moderations/{submission}`
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moderation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModerationsApi - functional programming interface
 * @export
 */
export const ModerationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModerationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderationsCreate(moderation?: Moderation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Moderation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderationsCreate(moderation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderationsDestroy(submission: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderationsDestroy(submission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'accepted' | 'pending' | 'rejected'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderationsList(limit?: number, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rejected', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedModerationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderationsList(limit, offset, ordering, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {PatchedModeration} [patchedModeration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderationsPartialUpdate(submission: number, patchedModeration?: PatchedModeration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Moderation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderationsPartialUpdate(submission, patchedModeration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderationsRetrieve(submission: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Moderation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderationsRetrieve(submission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderationsUpdate(submission: number, moderation?: Moderation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Moderation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderationsUpdate(submission, moderation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModerationsApi - factory interface
 * @export
 */
export const ModerationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModerationsApiFp(configuration)
    return {
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsCreate(moderation?: Moderation, options?: any): AxiosPromise<Moderation> {
            return localVarFp.moderationsCreate(moderation, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsDestroy(submission: number, options?: any): AxiosPromise<void> {
            return localVarFp.moderationsDestroy(submission, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'accepted' | 'pending' | 'rejected'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsList(limit?: number, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rejected', options?: any): AxiosPromise<PaginatedModerationList> {
            return localVarFp.moderationsList(limit, offset, ordering, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {PatchedModeration} [patchedModeration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsPartialUpdate(submission: number, patchedModeration?: PatchedModeration, options?: any): AxiosPromise<Moderation> {
            return localVarFp.moderationsPartialUpdate(submission, patchedModeration, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsRetrieve(submission: number, options?: any): AxiosPromise<Moderation> {
            return localVarFp.moderationsRetrieve(submission, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submission A unique value identifying this moderation.
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderationsUpdate(submission: number, moderation?: Moderation, options?: any): AxiosPromise<Moderation> {
            return localVarFp.moderationsUpdate(submission, moderation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModerationsApi - object-oriented interface
 * @export
 * @class ModerationsApi
 * @extends {BaseAPI}
 */
export class ModerationsApi extends BaseAPI {
    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {Moderation} [moderation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerationsApi
     */
    public moderationsCreate(moderation?: Moderation, options?: any) {
        return ModerationsApiFp(this.configuration).moderationsCreate(moderation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this moderation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerationsApi
     */
    public moderationsDestroy(submission: number, options?: any) {
        return ModerationsApiFp(this.configuration).moderationsDestroy(submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {'accepted' | 'pending' | 'rejected'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerationsApi
     */
    public moderationsList(limit?: number, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rejected', options?: any) {
        return ModerationsApiFp(this.configuration).moderationsList(limit, offset, ordering, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this moderation.
     * @param {PatchedModeration} [patchedModeration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerationsApi
     */
    public moderationsPartialUpdate(submission: number, patchedModeration?: PatchedModeration, options?: any) {
        return ModerationsApiFp(this.configuration).moderationsPartialUpdate(submission, patchedModeration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this moderation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerationsApi
     */
    public moderationsRetrieve(submission: number, options?: any) {
        return ModerationsApiFp(this.configuration).moderationsRetrieve(submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submission A unique value identifying this moderation.
     * @param {Moderation} [moderation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerationsApi
     */
    public moderationsUpdate(submission: number, moderation?: Moderation, options?: any) {
        return ModerationsApiFp(this.configuration).moderationsUpdate(submission, moderation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubmissionsApi - axios parameter creator
 * @export
 */
export const SubmissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Submission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsCreate: async (submission: Submission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('submissionsCreate', 'submission', submission)
            const localVarPath = `/submissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submissionsDestroy', 'id', id)
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsFetchDestroy: async (submissionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsFetchDestroy', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/fetch`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsFetchRetrieve: async (submissionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsFetchRetrieve', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/fetch`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsFetchUpdate: async (submissionId: number, fetch?: Fetch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsFetchUpdate', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/fetch`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fetch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {'failed' | 'passed' | 'pending'} [analysisStatus] 
         * @param {boolean} [analysisStatusIsnull] 
         * @param {boolean} [fetchGeneratedThumbnailIsnull] 
         * @param {boolean} [fetchIsnull] 
         * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [fetchStatus] 
         * @param {boolean} [fetchStatusIsnull] 
         * @param {boolean} [fetchThumbnailIsnull] 
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [moderationIsnull] 
         * @param {'accepted' | 'pending' | 'rejected'} [moderationStatus] 
         * @param {boolean} [moderationStatusIsnull] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsList: async (analysisStatus?: 'failed' | 'passed' | 'pending', analysisStatusIsnull?: boolean, fetchGeneratedThumbnailIsnull?: boolean, fetchIsnull?: boolean, fetchStatus?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', fetchStatusIsnull?: boolean, fetchThumbnailIsnull?: boolean, limit?: number, moderationIsnull?: boolean, moderationStatus?: 'accepted' | 'pending' | 'rejected', moderationStatusIsnull?: boolean, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/submissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (analysisStatus !== undefined) {
                localVarQueryParameter['analysis__status'] = analysisStatus;
            }

            if (analysisStatusIsnull !== undefined) {
                localVarQueryParameter['analysis__status__isnull'] = analysisStatusIsnull;
            }

            if (fetchGeneratedThumbnailIsnull !== undefined) {
                localVarQueryParameter['fetch__generated_thumbnail__isnull'] = fetchGeneratedThumbnailIsnull;
            }

            if (fetchIsnull !== undefined) {
                localVarQueryParameter['fetch__isnull'] = fetchIsnull;
            }

            if (fetchStatus !== undefined) {
                localVarQueryParameter['fetch__status'] = fetchStatus;
            }

            if (fetchStatusIsnull !== undefined) {
                localVarQueryParameter['fetch__status__isnull'] = fetchStatusIsnull;
            }

            if (fetchThumbnailIsnull !== undefined) {
                localVarQueryParameter['fetch__thumbnail__isnull'] = fetchThumbnailIsnull;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (moderationIsnull !== undefined) {
                localVarQueryParameter['moderation__isnull'] = moderationIsnull;
            }

            if (moderationStatus !== undefined) {
                localVarQueryParameter['moderation__status'] = moderationStatus;
            }

            if (moderationStatusIsnull !== undefined) {
                localVarQueryParameter['moderation__status__isnull'] = moderationStatusIsnull;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsModerationDestroy: async (submissionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsModerationDestroy', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/moderation`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsModerationRetrieve: async (submissionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsModerationRetrieve', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/moderation`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsModerationUpdate: async (submissionId: number, moderation?: Moderation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsModerationUpdate', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/moderation`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moderation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {PatchedSubmission} [patchedSubmission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsPartialUpdate: async (id: number, patchedSubmission?: PatchedSubmission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submissionsPartialUpdate', 'id', id)
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSubmission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submissionsRetrieve', 'id', id)
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {Submission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsUpdate: async (id: number, submission: Submission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submissionsUpdate', 'id', id)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('submissionsUpdate', 'submission', submission)
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId 
         * @param {Vote} [vote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsVotesCreate: async (submissionId: number, vote?: Vote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsVotesCreate', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/votes`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsVotesList: async (submissionId: number, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsVotesList', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submission_id}/votes`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionsApi - functional programming interface
 * @export
 */
export const SubmissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Submission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsCreate(submission: Submission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsCreate(submission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsFetchDestroy(submissionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsFetchDestroy(submissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsFetchRetrieve(submissionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fetch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsFetchRetrieve(submissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsFetchUpdate(submissionId: number, fetch?: Fetch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fetch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsFetchUpdate(submissionId, fetch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {'failed' | 'passed' | 'pending'} [analysisStatus] 
         * @param {boolean} [analysisStatusIsnull] 
         * @param {boolean} [fetchGeneratedThumbnailIsnull] 
         * @param {boolean} [fetchIsnull] 
         * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [fetchStatus] 
         * @param {boolean} [fetchStatusIsnull] 
         * @param {boolean} [fetchThumbnailIsnull] 
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [moderationIsnull] 
         * @param {'accepted' | 'pending' | 'rejected'} [moderationStatus] 
         * @param {boolean} [moderationStatusIsnull] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsList(analysisStatus?: 'failed' | 'passed' | 'pending', analysisStatusIsnull?: boolean, fetchGeneratedThumbnailIsnull?: boolean, fetchIsnull?: boolean, fetchStatus?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', fetchStatusIsnull?: boolean, fetchThumbnailIsnull?: boolean, limit?: number, moderationIsnull?: boolean, moderationStatus?: 'accepted' | 'pending' | 'rejected', moderationStatusIsnull?: boolean, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubmissionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsList(analysisStatus, analysisStatusIsnull, fetchGeneratedThumbnailIsnull, fetchIsnull, fetchStatus, fetchStatusIsnull, fetchThumbnailIsnull, limit, moderationIsnull, moderationStatus, moderationStatusIsnull, offset, ordering, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsModerationDestroy(submissionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsModerationDestroy(submissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsModerationRetrieve(submissionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Moderation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsModerationRetrieve(submissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsModerationUpdate(submissionId: number, moderation?: Moderation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Moderation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsModerationUpdate(submissionId, moderation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {PatchedSubmission} [patchedSubmission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsPartialUpdate(id: number, patchedSubmission?: PatchedSubmission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsPartialUpdate(id, patchedSubmission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {Submission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsUpdate(id: number, submission: Submission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsUpdate(id, submission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId 
         * @param {Vote} [vote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsVotesCreate(submissionId: number, vote?: Vote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsVotesCreate(submissionId, vote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsVotesList(submissionId: number, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVoteList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsVotesList(submissionId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubmissionsApi - factory interface
 * @export
 */
export const SubmissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmissionsApiFp(configuration)
    return {
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {Submission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsCreate(submission: Submission, options?: any): AxiosPromise<Submission> {
            return localVarFp.submissionsCreate(submission, options).then((request) => request(axios, basePath));
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.submissionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsFetchDestroy(submissionId: number, options?: any): AxiosPromise<void> {
            return localVarFp.submissionsFetchDestroy(submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsFetchRetrieve(submissionId: number, options?: any): AxiosPromise<Fetch> {
            return localVarFp.submissionsFetchRetrieve(submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this fetch.
         * @param {Fetch} [fetch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsFetchUpdate(submissionId: number, fetch?: Fetch, options?: any): AxiosPromise<Fetch> {
            return localVarFp.submissionsFetchUpdate(submissionId, fetch, options).then((request) => request(axios, basePath));
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {'failed' | 'passed' | 'pending'} [analysisStatus] 
         * @param {boolean} [analysisStatusIsnull] 
         * @param {boolean} [fetchGeneratedThumbnailIsnull] 
         * @param {boolean} [fetchIsnull] 
         * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [fetchStatus] 
         * @param {boolean} [fetchStatusIsnull] 
         * @param {boolean} [fetchThumbnailIsnull] 
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [moderationIsnull] 
         * @param {'accepted' | 'pending' | 'rejected'} [moderationStatus] 
         * @param {boolean} [moderationStatusIsnull] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsList(analysisStatus?: 'failed' | 'passed' | 'pending', analysisStatusIsnull?: boolean, fetchGeneratedThumbnailIsnull?: boolean, fetchIsnull?: boolean, fetchStatus?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', fetchStatusIsnull?: boolean, fetchThumbnailIsnull?: boolean, limit?: number, moderationIsnull?: boolean, moderationStatus?: 'accepted' | 'pending' | 'rejected', moderationStatusIsnull?: boolean, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim', options?: any): AxiosPromise<PaginatedSubmissionList> {
            return localVarFp.submissionsList(analysisStatus, analysisStatusIsnull, fetchGeneratedThumbnailIsnull, fetchIsnull, fetchStatus, fetchStatusIsnull, fetchThumbnailIsnull, limit, moderationIsnull, moderationStatus, moderationStatusIsnull, offset, ordering, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsModerationDestroy(submissionId: number, options?: any): AxiosPromise<void> {
            return localVarFp.submissionsModerationDestroy(submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsModerationRetrieve(submissionId: number, options?: any): AxiosPromise<Moderation> {
            return localVarFp.submissionsModerationRetrieve(submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId A unique value identifying this moderation.
         * @param {Moderation} [moderation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsModerationUpdate(submissionId: number, moderation?: Moderation, options?: any): AxiosPromise<Moderation> {
            return localVarFp.submissionsModerationUpdate(submissionId, moderation, options).then((request) => request(axios, basePath));
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {PatchedSubmission} [patchedSubmission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsPartialUpdate(id: number, patchedSubmission?: PatchedSubmission, options?: any): AxiosPromise<Submission> {
            return localVarFp.submissionsPartialUpdate(id, patchedSubmission, options).then((request) => request(axios, basePath));
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsRetrieve(id: number, options?: any): AxiosPromise<Submission> {
            return localVarFp.submissionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this submission.
         * @param {Submission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsUpdate(id: number, submission: Submission, options?: any): AxiosPromise<Submission> {
            return localVarFp.submissionsUpdate(id, submission, options).then((request) => request(axios, basePath));
        },
        /**
         * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId 
         * @param {Vote} [vote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsVotesCreate(submissionId: number, vote?: Vote, options?: any): AxiosPromise<Vote> {
            return localVarFp.submissionsVotesCreate(submissionId, vote, options).then((request) => request(axios, basePath));
        },
        /**
         * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} submissionId 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsVotesList(submissionId: number, limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedVoteList> {
            return localVarFp.submissionsVotesList(submissionId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmissionsApi - object-oriented interface
 * @export
 * @class SubmissionsApi
 * @extends {BaseAPI}
 */
export class SubmissionsApi extends BaseAPI {
    /**
     * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {Submission} submission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsCreate(submission: Submission, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsCreate(submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsDestroy(id: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId A unique value identifying this fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsFetchDestroy(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsFetchDestroy(submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId A unique value identifying this fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsFetchRetrieve(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsFetchRetrieve(submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SFetching results attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId A unique value identifying this fetch.
     * @param {Fetch} [fetch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsFetchUpdate(submissionId: number, fetch?: Fetch, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsFetchUpdate(submissionId, fetch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {'failed' | 'passed' | 'pending'} [analysisStatus] 
     * @param {boolean} [analysisStatusIsnull] 
     * @param {boolean} [fetchGeneratedThumbnailIsnull] 
     * @param {boolean} [fetchIsnull] 
     * @param {'fetched' | 'pending' | 'rej_error' | 'rej_fetch'} [fetchStatus] 
     * @param {boolean} [fetchStatusIsnull] 
     * @param {boolean} [fetchThumbnailIsnull] 
     * @param {number} [limit] Number of results to return per page.
     * @param {boolean} [moderationIsnull] 
     * @param {'accepted' | 'pending' | 'rejected'} [moderationStatus] 
     * @param {boolean} [moderationStatusIsnull] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsList(analysisStatus?: 'failed' | 'passed' | 'pending', analysisStatusIsnull?: boolean, fetchGeneratedThumbnailIsnull?: boolean, fetchIsnull?: boolean, fetchStatus?: 'fetched' | 'pending' | 'rej_error' | 'rej_fetch', fetchStatusIsnull?: boolean, fetchThumbnailIsnull?: boolean, limit?: number, moderationIsnull?: boolean, moderationStatus?: 'accepted' | 'pending' | 'rejected', moderationStatusIsnull?: boolean, offset?: number, ordering?: string, status?: 'accepted' | 'pending' | 'rej_banned' | 'rej_fetch' | 'rej_mod' | 'rej_sentim', options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsList(analysisStatus, analysisStatusIsnull, fetchGeneratedThumbnailIsnull, fetchIsnull, fetchStatus, fetchStatusIsnull, fetchThumbnailIsnull, limit, moderationIsnull, moderationStatus, moderationStatusIsnull, offset, ordering, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId A unique value identifying this moderation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsModerationDestroy(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsModerationDestroy(submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId A unique value identifying this moderation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsModerationRetrieve(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsModerationRetrieve(submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderation attached to a submission  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId A unique value identifying this moderation.
     * @param {Moderation} [moderation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsModerationUpdate(submissionId: number, moderation?: Moderation, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsModerationUpdate(submissionId, moderation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this submission.
     * @param {PatchedSubmission} [patchedSubmission] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsPartialUpdate(id: number, patchedSubmission?: PatchedSubmission, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsPartialUpdate(id, patchedSubmission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsRetrieve(id: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submitted articles for review  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this submission.
     * @param {Submission} submission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsUpdate(id: number, submission: Submission, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsUpdate(id, submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId 
     * @param {Vote} [vote] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsVotesCreate(submissionId: number, vote?: Vote, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsVotesCreate(submissionId, vote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Vote management /submissions/(id)/votes (get, post)  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} submissionId 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsVotesList(submissionId: number, limit?: number, offset?: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsVotesList(submissionId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCreate', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDestroy', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUser?: PatchedUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersUpdate', 'user', user)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersCreate(user, options).then((request) => request(axios, basePath));
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedUserList> {
            return localVarFp.usersList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(user: User, options?: any) {
        return UsersApiFp(this.configuration).usersCreate(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDestroy(id: number, options?: any) {
        return UsersApiFp(this.configuration).usersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(limit?: number, offset?: number, options?: any) {
        return UsersApiFp(this.configuration).usersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUser} [patchedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: any) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *   **Permission restrictions:** + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this user.
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, user: User, options?: any) {
        return UsersApiFp(this.configuration).usersUpdate(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VotesApi - axios parameter creator
 * @export
 */
export const VotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('votesDestroy', 'id', id)
            const localVarPath = `/votes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('votesRetrieve', 'id', id)
            const localVarPath = `/votes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VotesApi - functional programming interface
 * @export
 */
export const VotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VotesApiAxiosParamCreator(configuration)
    return {
        /**
         * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votesDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VotesApi - factory interface
 * @export
 */
export const VotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VotesApiFp(configuration)
    return {
        /**
         * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.votesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesRetrieve(id: number, options?: any): AxiosPromise<Vote> {
            return localVarFp.votesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VotesApi - object-oriented interface
 * @export
 * @class VotesApi
 * @extends {BaseAPI}
 */
export class VotesApi extends BaseAPI {
    /**
     * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this vote.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesApi
     */
    public votesDestroy(id: number, options?: any) {
        return VotesApiFp(this.configuration).votesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Vote management, through /votes (put, patch, destroy) or through  **Permission restrictions:** + `IsAuthenticated`: *Rejects all operations if the user is not authenticated* + `IsOwnerOrModeratorOrStaff`: *Blocks update/partial_updated/destroy if:     * the user is NOT in the staff group     * AND if the model has a property called \'owner\' and its value differs from the request user     * AND if the user is not in the Moderators group     Everything else is allowed* + `DjangoModelPermissions`: *The request is authenticated using `django.contrib.auth` permissions.     See: https://docs.djangoproject.com/en/dev/topics/auth/#permissions      It ensures that the user is authenticated, and has the appropriate     `add`/`change`/`delete` permissions on the model.      This permission can only be applied against view classes that     provide a `.queryset` attribute.*
     * @param {number} id A unique integer value identifying this vote.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesApi
     */
    public votesRetrieve(id: number, options?: any) {
        return VotesApiFp(this.configuration).votesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


